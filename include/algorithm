#pragma once

#include <detail/config.hpp>
#include <execution_policy>
#include_next <algorithm>
#include <iostream>
#include <thrust/execution_policy.h>
#include <thrust/logical.h>
#include <thrust/find.h>
#include <thrust/count.h>
#include <thrust/unique.h>
#include <thrust/mismatch.h>
#include <thrust/equal.h>
#include <thrust/for_each.h>
#include <thrust/remove.h>

namespace std
{


template<class InputIterator, class Predicate>
bool __all_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::all_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __all_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::all_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __all_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __all_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __all_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class Predicate>
bool __any_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::any_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __any_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::any_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __any_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __any_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __any_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class Predicate>
bool __none_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::none_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __none_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::none_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __none_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __none_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __none_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class T>
InputIterator __find(const sequential_execution_policy &, InputIterator first, InputIterator last, const T& value)
{
  return thrust::find(thrust::seq, first, last, value);
}


template<class InputIterator, class T>
InputIterator __find(const parallel_execution_policy &, InputIterator first, InputIterator last, const T& value)
{
  return thrust::find(thrust::device, first, last, value);
}


template<class InputIterator, class T>
InputIterator __find(const execution_policy &exec, InputIterator first, InputIterator last, const T& value)
{
  switch(__which(exec))
  {
    case 0:
      last = __find(__union(exec).seq, first, last, value);
      break;

    case 1:
      last = __find(__union(exec).par, first, last, value);
      break;
  }

  return last;
}


template<class InputIterator, class Predicate>
InputIterator __find_if(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  switch(__which(exec))
  {
    case 0:
      last = __find_if(__union(exec).seq, first, last, pred);
      break;

    case 1:
      last = __find_if(__union(exec).par, first, last, pred);
      break;
  }

  return last;
}


template<class InputIterator, class Predicate>
InputIterator __find_if_not(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if_not(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if_not(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if_not(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if_not(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  switch(__which(exec))
  {
    case 0:
      last = __find_if_not(__union(exec).seq, first, last, pred);
      break;

    case 1:
      last = __find_if_not(__union(exec).par, first, last, pred);
      break;
  }

  return last;
}


template<class ForwardIterator1, class ForwardIterator2>
ForwardIterator1 __find_end(const sequential_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2);
}


template<class ForwardIterator1, class ForwardIterator2>
ForwardIterator1 __find_end(const parallel_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2);
}


template<class ForwardIterator1, class ForwardIterator2>
ForwardIterator1 __find_end(const execution_policy &exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_end(__union(exec).seq, first1, last1, first2, last2);
      break;

    case 1:
      first1 = __find_end(__union(exec).par, first1, last1, first2, last2);
  }

  return first1;
}


template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
ForwardIterator1 __find_end(const sequential_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2, pred);
}


template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
ForwardIterator1 __find_end(const parallel_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2, pred);
}


template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
ForwardIterator1 __find_end(const execution_policy &exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_end(__union(exec).seq, first1, last1, first2, last2, pred);
      break;

    case 1:
      first1 = __find_end(__union(exec).par, first1, last1, first2, last2, pred);
  }

  return first1;
}


template<class InputIterator, class ForwardIterator>
InputIterator __find_first_of(const sequential_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2);
}


template<class InputIterator, class ForwardIterator>
InputIterator __find_first_of(const parallel_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2);
} 

template<class InputIterator, class ForwardIterator>
InputIterator __find_first_of(const execution_policy &exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_first_of(__union(exec).seq, first1, last1, first2, last2);
      break;

    case 1:
      first1 = __find_first_of(__union(exec).par, first1, last1, first2, last2);
      break;
  }

  return first1;
}


template<class InputIterator, class ForwardIterator, class BinaryPredicate>
InputIterator __find_first_of(const sequential_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2, pred);
}


template<class InputIterator, class ForwardIterator, class BinaryPredicate>
InputIterator __find_first_of(const parallel_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2, pred);
}


template<class InputIterator, class ForwardIterator, class BinaryPredicate>
InputIterator __find_first_of(const execution_policy &exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_first_of(__union(exec).seq, first1, last1, first2, last2, pred);
      break;

    case 1:
      first1 = __find_first_of(__union(exec).par, first1, last1, first2, last2, pred);
      break;
  }

  return first1;
}


template<class ForwardIterator>
ForwardIterator __adjacent_find(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last)
{
  return std::adjacent_find(first, last);
}


template<class ForwardIterator>
ForwardIterator __adjacent_find(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last)
{
  // XXX TODO
  return std::adjacent_find(first, last);
}


template<class ForwardIterator>
ForwardIterator __adjacent_find(const execution_policy &exec, ForwardIterator first, ForwardIterator last)
{
  switch(__which(exec))
  {
    case 0:
      first = __adjacent_find(__union(exec).seq, first, last);
      break;

    case 1:
      first = __adjacent_find(__union(exec).par, first, last);
  }

  return first;
}


template<class ForwardIterator, class Predicate>
ForwardIterator __adjacent_find(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last, Predicate pred)
{
  return std::adjacent_find(first, last, pred);
}


template<class ForwardIterator, class Predicate>
ForwardIterator __adjacent_find(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last, Predicate pred)
{
  // XXX TODO
  return std::adjacent_find(first, last, pred);
}


template<class ForwardIterator, class Predicate>
ForwardIterator __adjacent_find(const execution_policy &exec, ForwardIterator first, ForwardIterator last, Predicate pred)
{
  switch(__which(exec))
  {
    case 0:
      first = __adjacent_find(__union(exec).seq, first, last, pred);
      break;

    case 1:
      first = __adjacent_find(__union(exec).par, first, last, pred);
  }

  return first;
}


template<class InputIterator, class T>
typename std::iterator_traits<InputIterator>::difference_type
__count(const sequential_execution_policy &, InputIterator first, InputIterator last, const T &value)
{
  return std::count(first, last, value);
}


template<class InputIterator, class T>
typename std::iterator_traits<InputIterator>::difference_type
__count(const parallel_execution_policy &, InputIterator first, InputIterator last, const T &value)
{
  return thrust::count(thrust::device, first, last, value);
}


template<class InputIterator, class T>
typename std::iterator_traits<InputIterator>::difference_type
__count(const execution_policy &exec, InputIterator first, InputIterator last, const T &value)
{
  typename std::iterator_traits<InputIterator>::difference_type result(0);

  switch(__which(exec))
  {
    case 0:
      result = __count(__union(exec).seq, first, last, value);
      break;

    case 1:
      result = __count(__union(exec).par, first, last, value);
      break;
  }

  return result;
}


template<class InputIterator, class Predicate>
typename std::iterator_traits<InputIterator>::difference_type
__count_if(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return std::count_if(first, last, pred);
}


template<class InputIterator, class Predicate>
typename std::iterator_traits<InputIterator>::difference_type
__count_if(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::count_if(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
typename std::iterator_traits<InputIterator>::difference_type
__count_if(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  typename std::iterator_traits<InputIterator>::difference_type result(0);

  switch(__which(exec))
  {
    case 0:
      result = __count_if(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __count_if(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<typename InputIterator1, typename InputIterator2>
pair<InputIterator1,InputIterator2>
__mismatch(const sequential_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  return std::mismatch(first1, last1, first2);
}


template<typename InputIterator1, typename InputIterator2>
pair<InputIterator1,InputIterator2>
__mismatch(const parallel_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  thrust::pair<InputIterator1,InputIterator2> result = thrust::mismatch(thrust::device, first1, last1, first2);
  return std::make_pair(result.first, result.second);
}


template<typename InputIterator1, typename InputIterator2>
pair<InputIterator1,InputIterator2>
__mismatch(const execution_policy &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  pair<InputIterator1,InputIterator2> result(first1,first2);

  switch(__which(exec))
  {
    case 0:
      result = __mismatch(__union(exec).seq, first1, last1, first2);
      break;

    case 1:
      result = __mismatch(__union(exec).par, first1, last1, first2);
      break;
  }

  return result;
}


template<typename InputIterator1, typename InputIterator2>
bool __equal_disambiguate(const sequential_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  return std::equal(first1, last1, first2);
}


template<typename InputIterator1, typename InputIterator2>
bool __equal_disambiguate(const parallel_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  return thrust::equal(thrust::device, first1, last1, first2);
}


template<typename InputIterator1, typename InputIterator2>
bool __equal_disambiguate(const execution_policy &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __equal_disambiguate(__union(exec).seq, first1, last1, first2);
      break;

    case 1:
      result = __equal_disambiguate(__union(exec).par, first1, last1, first2);
      break;
  }

  return result;
}


template<typename InputIterator1, typename InputIterator2, typename Predicate>
bool __equal_disambiguate(const sequential_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, Predicate pred)
{
  return std::equal(first1, last1, first2, pred);
}


template<typename InputIterator1, typename InputIterator2, typename Predicate>
bool __equal_disambiguate(const parallel_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, Predicate pred)
{
  bool result = false;
  return thrust::equal(thrust::device, first1, last1, first2, pred);
}


template<typename InputIterator1, typename InputIterator2, typename Predicate>
bool __equal_disambiguate(const execution_policy &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __equal_disambiguate(__union(exec).seq, first1, last1, first2, pred);
      break;

    case 1:
      result = __equal_disambiguate(__union(exec).par, first1, last1, first2, pred);
      break;
  }

  return result;
}


template<typename InputIterator1, typename InputIterator2>
InputIterator2 __copy(const sequential_execution_policy &, InputIterator1 first, InputIterator1 last, InputIterator2 result)
{
  return std::copy(first, last, result);
}


template<typename InputIterator1, typename InputIterator2>
InputIterator2 __copy(const parallel_execution_policy &, InputIterator1 first, InputIterator1 last, InputIterator2 result)
{
  return thrust::copy(thrust::device, first, last, result);
}


template<typename InputIterator1, typename InputIterator2>
InputIterator2 __copy(const execution_policy &exec, InputIterator1 first, InputIterator1 last, InputIterator2 result)
{
  switch(__which(exec))
  {
    case 0:
      result = __copy(__union(exec).seq, first, last, result);
      break;

    case 1:
      result = __copy(__union(exec).par, first, last, result);
      break;
  }

  return result;
}


template<typename InputIterator1, typename Size, typename InputIterator2>
InputIterator2 __copy_n(const sequential_execution_policy &, InputIterator1 first, Size n, InputIterator2 result)
{
  return std::copy_n(first, n, result);
}


template<typename InputIterator1, typename Size, typename InputIterator2>
InputIterator2 __copy_n(const parallel_execution_policy &, InputIterator1 first, Size n, InputIterator2 result)
{
  return thrust::copy_n(thrust::device, first, n, result);
}


template<typename InputIterator1, typename Size, typename InputIterator2>
InputIterator2 __copy_n(const execution_policy &exec, InputIterator1 first, Size n, InputIterator2 result)
{
  switch(__which(exec))
  {
    case 0:
      result = __copy_n(__union(exec).seq, first, n, result);
      break;

    case 1:
      result = __copy_n(__union(exec).par, first, n, result);
      break;
  }

  return result;
}


template<typename InputIterator1, typename InputIterator2>
InputIterator2 __move(const sequential_execution_policy &, InputIterator1 first, InputIterator1 last, InputIterator2 result)
{
  return std::move(first, last, result);
}


template<typename InputIterator1, typename InputIterator2>
InputIterator2 __move(const parallel_execution_policy &, InputIterator1 first, InputIterator1 last, InputIterator2 result)
{
  // XXX TODO
  return std::move(first, last, result);
}


template<typename InputIterator1, typename InputIterator2>
InputIterator2 __move(const execution_policy &exec, InputIterator1 first, InputIterator1 last, InputIterator2 result)
{
  switch(__which(exec))
  {
    case 0:
      result = __move(__union(exec).seq, first, last, result);
      break;

    case 1:
      result = __move(__union(exec).par, first, last, result);
      break;
  }

  return result;
}


template<typename ForwardIterator1, typename ForwardIterator2>
ForwardIterator2 __swap_ranges(const sequential_execution_policy &, ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 result)
{
  return thrust::swap_ranges(thrust::seq, first, last, result);
}


template<typename ForwardIterator1, typename ForwardIterator2>
ForwardIterator2 __swap_ranges(const parallel_execution_policy &, ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 result)
{
  return thrust::swap_ranges(thrust::device, first, last, result);
}


template<typename ForwardIterator1, typename ForwardIterator2>
ForwardIterator2 __swap_ranges(const execution_policy &exec, ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 result)
{
  switch(__which(exec))
  {
    case 0:
      result = __swap_ranges(__union(exec).seq, first, last, result);
      break;

    case 1:
      result = __swap_ranges(__union(exec).par, first, last, result);
      break;
  }

  return result;
}


template<typename InputIterator, typename OutputIterator, typename UnaryOperation>
OutputIterator __transform(const sequential_execution_policy &, InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op)
{
  return thrust::transform(thrust::seq, first, last, result, op);
}


template<typename InputIterator, typename OutputIterator, typename UnaryOperation>
OutputIterator __transform(const parallel_execution_policy &, InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op)
{
  return thrust::transform(thrust::device, first, last, result, op);
}


template<typename InputIterator, typename OutputIterator, typename UnaryOperation>
OutputIterator __transform(const execution_policy &exec, InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op)
{
  switch(__which(exec))
  {
    case 0:
      result = __transform(__union(exec).seq, first, last, result);
      break;

    case 1:
      result = __transform(__union(exec).par, first, last, result);
      break;
  }

  return result;
}


template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryOperation>
OutputIterator __transform(const sequential_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation op)
{
  return thrust::transform(thrust::seq, first1, last1, first2, result, op);
}


template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryOperation>
OutputIterator __transform(const parallel_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation op)
{
  return thrust::transform(thrust::device, first1, last1, first2, result, op);
}


template<typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryOperation>
OutputIterator __transform(const execution_policy &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation op)
{
  switch(__which(exec))
  {
    case 0:
      result = __transform(__union(exec).seq, first1, last1, first2, result, op);
      break;

    case 1:
      result = __transform(__union(exec).par, first1, last1, first2, result, op);
      break;
  }

  return result;
}


template<typename ForwardIterator, typename T>
void __replace(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value)
{
  return thrust::replace(thrust::seq, first, last, old_value, new_value);
}


template<typename ForwardIterator, typename T>
void __replace(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value)
{
  return thrust::replace(thrust::device, first, last, old_value, new_value);
}


template<typename ForwardIterator, typename T>
void __replace(const execution_policy &exec, ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value)
{
  switch(__which(exec))
  {
    case 0:
      __replace(__union(exec).seq, first, last, old_value, new_value);
      break;

    case 1:
      __replace(__union(exec).par, first, last, old_value, new_value);
      break;
  }
}


template<typename ForwardIterator, typename Predicate, typename T>
void __replace_if(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value)
{
  return thrust::replace_if(thrust::seq, first, last, pred, new_value);
}


template<typename ForwardIterator, typename Predicate, typename T>
void __replace_if(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value)
{
  return thrust::replace_if(thrust::device, first, last, pred, new_value);
}


template<typename ForwardIterator, typename Predicate, typename T>
void __replace_if(const execution_policy &exec, ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value)
{
  switch(__which(exec))
  {
    case 0:
      __replace_if(__union(exec).seq, first, last, pred, new_value);
      break;

    case 1:
      __replace_if(__union(exec).par, first, last, pred, new_value);
      break;
  }
}


template<class ForwardIterator, class T>
void __fill(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last, const T& value)
{
  std::fill(first, last, value); 
}


template<class ForwardIterator, class T>
void __fill(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last, const T& value)
{
  thrust::fill(thrust::device, first, last, value); 
}


template<class ForwardIterator, class T>
void __fill(const execution_policy &exec, ForwardIterator first, ForwardIterator last, const T& value)
{
  switch(__which(exec))
  {
    case 0:
      __fill(__union(exec).seq, first, last, value);
      break;

    case 1:
      __fill(__union(exec).par, first, last, value);
      break;
  }
}


template<class OutputIterator, class Size, class T>
void __fill_n(const sequential_execution_policy &, OutputIterator first, Size n, const T& value)
{
  std::fill_n(first, n, value);
}


template<class OutputIterator, class Size, class T>
void __fill_n(const parallel_execution_policy &, OutputIterator first, Size n, const T& value)
{
  thrust::fill_n(thrust::device, first, n, value);
}


template<class OutputIterator, class Size, class T>
void __fill_n(const execution_policy &exec, OutputIterator first, Size n, const T& value)
{
  switch(__which(exec))
  {
    case 0:
      __fill_n(__union(exec).seq, first, n, value);
      break;

    case 1:
      __fill_n(__union(exec).par, first, n, value);
      break;
  }
}


template<class ForwardIterator, class Generator>
void __generate(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last, Generator gen)
{
  std::generate(first, last, gen); 
}


template<class ForwardIterator, class Generator>
void __generate(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last, Generator gen)
{
  thrust::generate(thrust::device, first, last, gen); 
}


template<class ForwardIterator, class Generator>
void __generate(const execution_policy &exec, ForwardIterator first, ForwardIterator last, Generator gen)
{
  switch(__which(exec))
  {
    case 0:
      __generate(__union(exec).seq, first, last, gen);
      break;

    case 1:
      __generate(__union(exec).par, first, last, gen);
      break;
  }
}


template<class OutputIterator, class Size, class Generator>
void __generate_n(const sequential_execution_policy &, OutputIterator first, Size n, Generator gen)
{
  std::generate_n(first, n, gen);
}


template<class OutputIterator, class Size, class Generator>
void __generate_n(const parallel_execution_policy &, OutputIterator first, Size n, Generator gen)
{
  thrust::generate_n(thrust::device, first, n, gen);
}


template<class OutputIterator, class Size, class Generator>
void __generate_n(const execution_policy &exec, OutputIterator first, Size n, Generator gen)
{
  switch(__which(exec))
  {
    case 0:
      __generate_n(__union(exec).seq, first, n, gen);
      break;

    case 1:
      __generate_n(__union(exec).par, first, n, gen);
      break;
  }
}


template<class ForwardIterator, class T>
ForwardIterator __remove(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last, const T& value)
{
  return std::remove(first, last, value);
}


template<class ForwardIterator, class T>
ForwardIterator __remove(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last, const T& value)
{
  return thrust::remove(thrust::device, first, last, value);
}


template<class ForwardIterator, class T>
ForwardIterator __remove(const execution_policy &exec, ForwardIterator first, ForwardIterator last, const T& value)
{
  ForwardIterator result = last;

  switch(__which(exec))
  {
    case 0:
      result = __remove(__union(exec).seq, first, last, value);
      break;

    case 1:
      result = __remove(__union(exec).par, first, last, value);
      break;
  }

  return result;
}


template<class ForwardIterator, class Predicate>
ForwardIterator __remove_if(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last, Predicate pred)
{
  return std::remove_if(first, last, pred);
}


template<class ForwardIterator, class Predicate>
ForwardIterator __remove_if(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last, Predicate pred)
{
  return thrust::remove_if(thrust::device, first, last, pred);
}


template<class ForwardIterator, class Predicate>
ForwardIterator __remove_if(const execution_policy &exec, ForwardIterator first, ForwardIterator last, Predicate pred)
{
  ForwardIterator result = last;

  switch(__which(exec))
  {
    case 0:
      result = __remove(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __remove(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class ForwardIterator, class OutputIterator, class T>
OutputIterator __remove_copy(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last, OutputIterator result, const T& value)
{
  return std::remove_copy(first, last, result, value);
}


template<class ForwardIterator, class OutputIterator, class T>
OutputIterator __remove_copy(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last, OutputIterator result, const T& value)
{
  return thrust::remove_copy(thrust::device, first, last, result, value);
}


template<class ForwardIterator, class OutputIterator, class T>
OutputIterator __remove_copy(const execution_policy &exec, ForwardIterator first, ForwardIterator last, OutputIterator result, const T& value)
{
  switch(__which(exec))
  {
    case 0:
      result = __remove_copy(__union(exec).seq, first, last, result, value);
      break;

    case 1:
      result = __remove_copy(__union(exec).par, first, last, result, value);
      break;
  }

  return result;
}


template<class ForwardIterator, class OutputIterator, class Predicate>
OutputIterator __remove_copy_if(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last, OutputIterator result, Predicate pred)
{
  return std::remove_copy_if(first, last, result, pred);
}


template<class ForwardIterator, class OutputIterator, class Predicate>
OutputIterator __remove_copy_if(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last, OutputIterator result, Predicate pred)
{
  return thrust::remove_copy_if(thrust::device, first, last, result, pred);
}


template<class ForwardIterator, class OutputIterator, class Predicate>
OutputIterator __remove_copy_if(const execution_policy &exec, ForwardIterator first, ForwardIterator last, OutputIterator result, Predicate pred)
{
  switch(__which(exec))
  {
    case 0:
      result = __remove_copy_if(__union(exec).seq, first, last, result, pred);
      break;

    case 1:
      result = __remove_copy_if(__union(exec).par, first, last, result, pred);
      break;
  }

  return result;
}


template<class ForwardIterator>
ForwardIterator __unique(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last)
{
  return std::unique(first, last);
}


template<class ForwardIterator>
ForwardIterator __unique(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last)
{
  return thrust::unique(thrust::device, first, last);
}


template<class ForwardIterator>
ForwardIterator __unique(const execution_policy &exec, ForwardIterator first, ForwardIterator last)
{
  ForwardIterator result = last;

  switch(__which(exec))
  {
    case 0:
      result = __unique(__union(exec).seq, first, last);
      break;

    case 1:
      result = __unique(__union(exec).par, first, last);
      break;
  }

  return result;
}


template<class ForwardIterator, class BinaryPredicate>
ForwardIterator __unique(const sequential_execution_policy &, ForwardIterator first, ForwardIterator last, BinaryPredicate pred)
{
  return std::unique(first, last, pred);
}


template<class ForwardIterator, class BinaryPredicate>
ForwardIterator __unique(const parallel_execution_policy &, ForwardIterator first, ForwardIterator last, BinaryPredicate pred)
{
  return thrust::unique(thrust::device, first, last, pred);
}


template<class ForwardIterator, class BinaryPredicate>
ForwardIterator __unique(const execution_policy &exec, ForwardIterator first, ForwardIterator last, BinaryPredicate pred)
{
  ForwardIterator result = last;

  switch(__which(exec))
  {
    case 0:
      result = __unique(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __unique(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class OutputIterator>
OutputIterator __unique_copy(const sequential_execution_policy &, InputIterator first, InputIterator last, OutputIterator result)
{
  return std::unique_copy(first, last, result);
}


template<class InputIterator, class OutputIterator>
OutputIterator __unique_copy(const parallel_execution_policy &, InputIterator first, InputIterator last, OutputIterator result)
{
  return thrust::unique_copy(thrust::device, first, last, result);
}


template<class InputIterator, class OutputIterator>
OutputIterator __unique_copy(const execution_policy &exec, InputIterator first, InputIterator last, OutputIterator result)
{
  switch(__which(exec))
  {
    case 0:
      result = __unique_copy(__union(exec).seq, first, last, result);
      break;

    case 1:
      result = __unique_copy(__union(exec).par, first, last, result);
      break;
  }

  return result;
}


template<class InputIterator, class OutputIterator, class BinaryPredicate>
OutputIterator __unique_copy(const sequential_execution_policy &, InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred)
{
  return std::unique_copy(first, last, result, pred);
}


template<class InputIterator, class OutputIterator, class BinaryPredicate>
OutputIterator __unique_copy(const parallel_execution_policy &, InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred)
{
  return thrust::unique_copy(thrust::device, first, last, result, pred);
}


template<class InputIterator, class OutputIterator, class BinaryPredicate>
OutputIterator __unique_copy(const execution_policy &exec, InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred)
{
  switch(__which(exec))
  {
    case 0:
      result = __unique_copy(__union(exec).seq, first, last, result, pred);
      break;

    case 1:
      result = __unique_copy(__union(exec).par, first, last, result, pred);
      break;
  }

  return result;
}


template<class BidirectionalIterator>
void __reverse(const sequential_execution_policy &, BidirectionalIterator first, BidirectionalIterator last)
{
  return std::reverse(first, last);
}


template<class BidirectionalIterator>
void __reverse(const parallel_execution_policy &, BidirectionalIterator first, BidirectionalIterator last)
{
  return thrust::reverse(thrust::device, first, last);
}


template<class BidirectionalIterator>
void __reverse(const execution_policy &exec, BidirectionalIterator first, BidirectionalIterator last)
{
  switch(__which(exec))
  {
    case 0:
      __reverse(__union(exec).seq, first, last);
      break;

    case 1:
      __reverse(__union(exec).par, first, last);
      break;
  }
}


template<class BidirectionalIterator, class OutputIterator>
OutputIterator __reverse_copy(const sequential_execution_policy &, BidirectionalIterator first, BidirectionalIterator last, OutputIterator result)
{
  return std::reverse_copy(first, last, result);
}


template<class BidirectionalIterator, class OutputIterator>
OutputIterator __reverse_copy(const parallel_execution_policy &, BidirectionalIterator first, BidirectionalIterator last, OutputIterator result)
{
  return thrust::reverse_copy(thrust::device, first, last, result);
}


template<class BidirectionalIterator, class OutputIterator>
OutputIterator __reverse_copy(const execution_policy &exec, BidirectionalIterator first, BidirectionalIterator last, OutputIterator result)
{
  switch(__which(exec))
  {
    case 0:
      result = __reverse_copy(__union(exec).seq, first, last, result);
      break;

    case 1:
      result = __reverse_copy(__union(exec).par, first, last, result);
      break;
  }

  return result;
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const sequential_execution_policy &, InputIterator first, InputIterator last, Function f)
{
  return thrust::for_each(thrust::seq, first, last, f);
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const parallel_execution_policy &, InputIterator first, InputIterator last, Function f)
{
  return thrust::for_each(thrust::device, first, last, f);
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const execution_policy &exec, InputIterator first, InputIterator last, Function f)
{
  switch(__which(exec))
  {
    case 0:
      first = __for_each(__union(exec).seq, first, last, f);
      break;

    case 1:
      first = __for_each(__union(exec).par, first, last, f);
      break;
  }

  return first;
}


template<class ExecutionPolicy, class Result = void>
struct __enable_if_execution_policy
  : std::enable_if<
      std::is_execution_policy<
        typename std::decay<ExecutionPolicy>::type
      >::value,
      Result
    >
{};


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,bool>::type
all_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __all_of(exec, first, last, pred);
}


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,bool>::type
any_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __any_of(exec, first, last, pred);
}


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,bool>::type
none_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __none_of(exec, first, last, pred);
}


template<class ExecutionPolicy, class InputIterator, class T>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find(ExecutionPolicy &&exec, InputIterator first, InputIterator last, const T& value)
{
  return __find(exec, first, last, value);
}


template<class ExecutionPolicy, class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_if(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __find_if(exec, first, last, pred);
}


template<class ExecutionPolicy, class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_if_not(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __find_if_not(exec, first, last, pred);
}


template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
typename __enable_if_execution_policy<ExecutionPolicy,ForwardIterator1>::type
find_end(ExecutionPolicy &&exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  return __find_end(exec, first1, last1, first2, last2);
}


template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
typename __enable_if_execution_policy<ExecutionPolicy,ForwardIterator1>::type
find_end(ExecutionPolicy &&exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  return __find_end(exec, first1, last1, first2, last2, pred);
}


template<class ExecutionPolicy, class InputIterator, class ForwardIterator>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_first_of(ExecutionPolicy &&exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  return __find_first_of(exec, first1, last1, first2, last2);
}


template<class ExecutionPolicy, class InputIterator, class ForwardIterator, class BinaryPredicate>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_first_of(ExecutionPolicy &&exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  return __find_first_of(exec, first1, last1, first2, last2, pred);
}


template<class ExecutionPolicy, class ForwardIterator>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  ForwardIterator
>::type
adjacent_find(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last)
{
  return __adjacent_find(exec, first, last);
}


template<class ExecutionPolicy, class ForwardIterator, class Predicate>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  ForwardIterator
>::type
adjacent_find(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last, Predicate pred)
{
  return __adjacent_find(exec, first, last, pred);
}


template<typename ExecutionPolicy, typename InputIterator, typename T>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  typename iterator_traits<InputIterator>::difference_type
>::type
count(ExecutionPolicy &&exec, InputIterator first, InputIterator last, const T &value)
{
  return __count(exec, first, last, value);
}


template<typename ExecutionPolicy, typename InputIterator, typename Predicate>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  typename iterator_traits<InputIterator>::difference_type
>::type
count_if(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __count_if(exec, first, last, pred);
}


template<typename ExecutionPolicy, typename InputIterator1, typename InputIterator2>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  pair<InputIterator1,InputIterator2>
>::type
mismatch(ExecutionPolicy &&exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  return __mismatch(exec, first1, last1, first2);
}


template<typename ExecutionPolicy, typename InputIterator1, typename InputIterator2, typename Predicate>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  pair<InputIterator1,InputIterator2>
>::type
mismatch(ExecutionPolicy &&exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, Predicate pred)
{
  return __mismatch(exec, first1, last1, first2, pred);
}


template<typename ExecutionPolicy, typename InputIterator1, typename InputIterator2>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  bool
>::type
equal(ExecutionPolicy &&exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  return __equal_disambiguate(exec, first1, last1, first2);
}


template<typename ExecutionPolicy, typename InputIterator1, typename InputIterator2, typename Predicate>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  bool
>::type
equal(ExecutionPolicy &&exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, Predicate pred)
{
  return __equal_disambiguate(exec, first1, last1, first2, pred);
}


template<typename ExecutionPolicy, typename InputIterator, typename Function>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
for_each(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Function f)
{
  return __for_each(exec, first, last, f);
}


template<typename ExecutionPolicy, typename InputIterator, typename OutputIterator>
typename __enable_if_execution_policy<ExecutionPolicy,OutputIterator>::type
copy(ExecutionPolicy &&exec, InputIterator first, InputIterator last, OutputIterator result)
{
  return __copy(exec, first, last, result);
}


template<typename ExecutionPolicy, typename InputIterator, typename Size, typename OutputIterator>
typename __enable_if_execution_policy<ExecutionPolicy,OutputIterator>::type
copy_n(ExecutionPolicy &&exec, InputIterator first, Size n, OutputIterator result)
{
  return __copy_n(exec, first, n, result);
}


template<typename ExecutionPolicy, typename InputIterator, typename OutputIterator>
typename __enable_if_execution_policy<ExecutionPolicy,OutputIterator>::type
move(ExecutionPolicy &&exec, InputIterator first, InputIterator last, OutputIterator result)
{
  return __move(exec, first, last, result);
}


template<typename ExecutionPolicy, typename ForwardIterator1, typename ForwardIterator2>
typename __enable_if_execution_policy<ExecutionPolicy,ForwardIterator2>::type
swap_ranges(ExecutionPolicy &&exec, ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 result)
{
  return __swap_ranges(exec, first, last, result);
}


template<typename ExecutionPolicy, typename InputIterator, typename OutputIterator, typename UnaryOperation>
typename __enable_if_execution_policy<ExecutionPolicy,OutputIterator>::type
transform(ExecutionPolicy &&exec, InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op)
{
  return __transform(exec, first, last, result, op);
}


template<typename ExecutionPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryOperation>
typename __enable_if_execution_policy<ExecutionPolicy,OutputIterator>::type
transform(ExecutionPolicy &&exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation op)
{
  return __transform(exec, first1, last1, first2, result, op);
}


template<class ExecutionPolicy, class ForwardIterator, class T>
typename __enable_if_execution_policy<ExecutionPolicy>::type
replace(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value)
{
  return __replace(exec, first, last, old_value, new_value);
}


template<class ExecutionPolicy, class ForwardIterator, class Predicate, class T>
typename __enable_if_execution_policy<ExecutionPolicy>::type
replace_if(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value)
{
  return __replace_if(exec, first, last, pred, new_value);
}


template<class ExecutionPolicy, class ForwardIterator, class T>
typename __enable_if_execution_policy<ExecutionPolicy>::type
fill(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last, const T& value)
{
  return __fill(exec, first, last, value);
}

template<class ExecutionPolicy, class OutputIterator, class Size, class T>
typename __enable_if_execution_policy<ExecutionPolicy>::type
fill_n(ExecutionPolicy &&exec, OutputIterator first, Size n, const T& value)
{
  return __fill_n(exec, first, n, value);
}


template<class ExecutionPolicy, class ForwardIterator, class Generator>
typename __enable_if_execution_policy<ExecutionPolicy>::type
generate(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last, Generator gen)
{
  return __generate(exec, first, last, gen);
}

template<class ExecutionPolicy, class OutputIterator, class Size, class Generator>
typename __enable_if_execution_policy<ExecutionPolicy>::type
generate_n(ExecutionPolicy &&exec, OutputIterator first, Size n, Generator gen)
{
  return __generate_n(exec, first, n, gen);
}


template<class ExecutionPolicy, class ForwardIterator, class T>
typename __enable_if_execution_policy<ExecutionPolicy,ForwardIterator>::type
remove(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last, const T& value)
{
  return __remove(exec, first, last, value);
}


template<class ExecutionPolicy, class ForwardIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,ForwardIterator>::type
remove_if(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last, Predicate pred)
{
  return __remove_if(exec, first, last, pred);
}


template<class ExecutionPolicy, class ForwardIterator, class OutputIterator, class T>
typename __enable_if_execution_policy<ExecutionPolicy,OutputIterator>::type
remove_copy(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last, OutputIterator result, const T& value)
{
  return __remove_copy(exec, first, last, result, value);
}


template<class ExecutionPolicy, class ForwardIterator, class OutputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,OutputIterator>::type
remove_copy_if(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last, OutputIterator result, Predicate pred)
{
  return __remove_copy_if(exec, first, last, result, pred);
}


template<class ExecutionPolicy, class ForwardIterator>
typename __enable_if_execution_policy<ExecutionPolicy,ForwardIterator>::type
unique(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last)
{
  return __unique(exec, first, last);
}


template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
typename __enable_if_execution_policy<ExecutionPolicy,ForwardIterator>::type
unique(ExecutionPolicy &&exec, ForwardIterator first, ForwardIterator last, BinaryPredicate pred)
{
  return __unique(exec, first, last, pred);
}


template<class ExecutionPolicy, class InputIterator, class OutputIterator>
typename __enable_if_execution_policy<ExecutionPolicy,OutputIterator>::type
unique_copy(ExecutionPolicy &&exec, InputIterator first, InputIterator last, OutputIterator result)
{
  return __unique_copy(exec, first, last, result);
}


template<class ExecutionPolicy, class InputIterator, class OutputIterator, class BinaryPredicate>
typename __enable_if_execution_policy<ExecutionPolicy,OutputIterator>::type
unique_copy(ExecutionPolicy &&exec, InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred)
{
  return __unique_copy(exec, first, last, result, pred);
}


template<class ExecutionPolicy, class BidirectionalIterator>
typename __enable_if_execution_policy<ExecutionPolicy>::type
reverse(ExecutionPolicy &&exec, BidirectionalIterator first, BidirectionalIterator last)
{
  return __reverse(exec, first, last);
}


template<class ExecutionPolicy, class BidirectionalIterator, class OutputIterator>
typename __enable_if_execution_policy<ExecutionPolicy, OutputIterator>::type
reverse_copy(ExecutionPolicy &&exec, BidirectionalIterator first, BidirectionalIterator last, OutputIterator result)
{
  return __reverse_copy(exec, first, last, result);
}


}

